//TODO：另一个TODO文件
//可以考虑一个树多种算法加多个bool来控制
/*
    各个方法处理方式的成本计算：

    假设树满6层，则为 4^0 + 4^1 + …… + 4^5 = 1365个节点，四叉树几乎不会满，为方便计算粗略记为1000个节点
    假设总共有约10000个碰撞器

    从树顶到树底的可剪枝递归，最少需要 6 次调用，最多需要 1+4+4+4+4+4=21 次调用，平均值约为 14
    从树顶到树底的可中断递归，最少 6 次，最多需要 1000 次，平均值为 500
    遍历所有节点的递归固定需要 1000

    从底向上的可中断递归，评价 3
    从底向上的递归，6

    单个节点的碰撞器约有 10 个碰撞器，则单个节点碰撞器遍历为 10
    单个节点碰撞器的可中断遍历则为 5

    假设每一帧有100个碰撞器存入，100个碰撞器删除，1000个碰撞器离开所属节点范围，1个碰撞器在删除时超出范围，500个碰撞器半径变大，500个半径变小

    存入：
        直接存入：剪枝递归 * 100 = 1400
        遍历存入：遍历 = 1000 【无法应对超出四叉树区域的存入】
    移除：
        直接移除：(剪枝递归+可中断遍历) * 100 + (可中断递归+遍历) = 1900 + 5500 = 7400
        遍历移除：遍历+遍历 = 11000
    节点数量更新：
    半径更新：
        存入移除时更新：(可中断递归+一次比较) * 100 + (可中断递归+可中断遍历) * 100 = 400 + 800 = 1200 【无法应对半径主动变化】
        半径变化时更新：(可中断递归+一次比较) * 500 + (可中断递归+可中断遍历) * 500 = 2000 + 4000 = 6000
        更新时更新：(遍历+遍历) = 11000
 */
 