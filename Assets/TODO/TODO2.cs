//TODO：另一个TODO文件
//可以考虑一个树多种算法加多个bool来控制
/*
 *  存入和移除需要一起拆分，一个方案是即时的，另一个是缓存到每一帧，这个需要
 */
/*
    各个方法处理方式的成本计算：

    假设树满6层，则为 4^0 + 4^1 + …… + 4^5 = 1365个节点，四叉树几乎不会满，为方便计算粗略记为1000个节点
    假设总共有约10000个碰撞器

    从树顶到树底的可剪枝递归，最少需要 6 次调用，最多需要 1+4+4+4+4+4=21 次调用，平均值约为 14
    从树顶到树底的可中断递归，最少 6 次，最多需要 1000 次，平均值为 500
    遍历所有节点的递归固定需要 1000

    从底向上的可中断递归，平均 3
    从底向上的递归，6

    单个节点的碰撞器约有 10 个碰撞器，则单个节点碰撞器遍历为 10
    单个节点碰撞器的可中断遍历则为 5

    假设每一帧有100个碰撞器存入，100个碰撞器删除，1000个碰撞器离开所属节点范围，1个碰撞器在删除时超出范围，500个碰撞器半径变大，500个半径变小

    存入：
        直接存入：剪枝递归 * 100 = 1400
        遍历存入：遍历 = 1000 【无法应对超出四叉树区域的存入】
    移除：
        直接移除：(剪枝递归+可中断遍历) * 100 + (可中断递归+遍历) = 1900 + 5500 = 7400
        遍历移除：遍历+遍历 = 11000
    节点数量更新：
    半径更新：
        存入移除时更新：(可中断递归+一次比较) * 100 + (可中断递归+可中断遍历) * 100 = 400 + 800 = 1200 【无法应对半径主动变化】
        半径变化时更新：(可中断递归+一次比较) * 500 + (可中断递归+可中断遍历) * 500 = 2000 + 4000 = 6000
        更新时更新：(遍历+遍历) = 11000
 */
/*
 *  即时处理比缓存处理快是因为不用遍历，针对处理比全部处理快是因为不用遍历，速度的关键在于如何不进行遍历
 *  
 *  将遍历转嫁到碰撞器上意义很小，遍历时调用次数和碰撞器数量相同，碰撞器自身调用次数则需要计算所有碰撞器的累积，结果是一样的
 */
/*
 *  无论即时更新还是统一更新，半径更新都需要在位置更新完成后进行，否则会导致移出原有节点的碰撞器将半径更新到原来的节点上
 *  
 *  为此无论是碰撞器发起更新还是树发起更新都需要先更新位置后更新半径
 */
/*
 *  如果将位置更新改为即时的将要面临一个巨大的挑战：移动到新节点时将无法直接通过位置寻找老节点
 *  
 *  统一更新位置的原理是遍历每个节点并检查需要重新存入的节点，原节点就是自身。针对更新按照经典四叉树原理，使用位置搜索，由于碰撞器已经移出节点范围将无法找到正确的节点
 *  
 *  可以考虑使用字典保存对应关系，直接通过字典进行移除。其问题在于如何在存入流程中向字典存入值，又在什么时候取出来
 *  
 *  可以考虑将节点作为返回值，这样null表示存入失败，包装类可以通过返回值获取节点并保存下来
 */
/*
 *  调整脚本执行时间或许有用，但需要注意这个设置能不能随着资源包导出
 *  即使不使用问题也不大，U3D自己的检测也不是保证在Update的末尾进行的
 */
