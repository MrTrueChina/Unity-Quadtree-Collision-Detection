/*

假设有 5层，10000 个碰撞器，1000 个节点，每次更新有 10% 碰撞器移动到其他节点，每次更新有 5% 节点移除与新增，1% 的节点合并，同时 1% 的节点拆分

不考虑缩放，缩放是节点内最大半径的更新相关，与增删速度无关

重复存入怎么办？


遍历节点 = 节点数 = 1000
遍历全树 = 遍历节点 + 碰撞器数 = 1000 + 10000 = 11000

直接移除节点 = 1
剪枝移除节点 = 层数 + 末梢节点数 / 2 = 5 + 5 = 10
全树移除节点 = 遍历全树 / 2 = 5500

添加节点 = 层数 = 5

分割节点 = 末梢节点数 = 10
合并节点 = 末梢节点数 * 4 = 40


累积到更新时处理

不能即时返回操作结果，逻辑分步骤且简洁

逻辑顺序：
第一次遍历：遍历整个树、移除需要移除的节点、移除并记录越界的节点、合并需要合并的节点
第一次遍历后：将越界的节点和新增的节点存入树，存入时根据需要进行分割

第一次遍历：
    遍历全树：11000
    移除节点：直接移除节点 * 500 = 500
    移除越界节点：直接移除节点 * 100 = 100
    合并节点：合并节点 * 10 = 400
第一次遍历后：
    添加节点：添加节点 * 500 = 2500
    添加越界节点：添加节点 * 100 = 500
    分割节点：分割节点 * 10 * 100

合并 = 11000 + 500 + 100 + 400 + 2500 + 500 + 100 = 15100


即时处理

即时返回操作结果，移除功能有缺陷

逻辑顺序：
存入：将节点存入树，根据需要进行分割
移除：根据位置进行移除，如果根据位置移除失败，则全树移除，之后按照需要合并
更新遍历：遍历整个树，移除并记录越界的节点，合并需要合并的节点
更新遍历后：将越界的节点存入树，根据需要分割

存入：
    添加节点 * 500 = 2500
移除：
    剪枝移除：剪枝移除节点 * 500 = 5000
    对越界节点进行全树移除：全树移除 * 500 * 5% = 5500 * 25 = 137500
更新遍历：
    遍历全树 = 11000
    移除越界节点：直接移除节点 * 100 = 100
    合并节点：合并节点 * 10 = 400
更新遍历后：
    添加越界节点：添加节点 * 100 = 500
    分割节点：分割节点 * 10 * 100

合并 = 2500 + 5000 + 137500 + 11000 + 100 + 400 + 500 + 100 = 157100


带有字典索引的即时处理

即时返回操作结果，逻辑纠缠复杂，因为存储了字典，可以更简单的解决重复存入问题

逻辑顺序：
存入：将节点存入树，根据需要进行分割
移除：根据字典进行删除，之后按照需要合并
更新遍历：遍历整个树，移除并记录越界的节点，合并需要合并的节点
更新遍历后：将越界的节点存入树，根据需要分割

存入：
    添加节点 * 500 = 2500
移除：
    直接移除节点 * 500 = 500
更新遍历：
    遍历全树 = 11000
    移除越界节点：直接移除节点 * 100 = 100
    合并节点：合并节点 * 10 = 400
更新遍历后：
    添加越界节点：添加节点 * 100 = 500
    分割节点：分割节点 * 10 * 100

合并 = 2500 + 500 + 11000 + 100 + 400 + 500 + 100 = 15100


考虑到维护字典，带字典的即时处理在内存和速度上都比更新时处理消耗大，但可以返回操作结果，Debug 也更方便
 */
